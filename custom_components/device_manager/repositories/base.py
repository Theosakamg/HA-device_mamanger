"""Base repository with generic CRUD operations."""

import logging
from typing import Any, Optional

from ..services.database_manager import DatabaseManager

_LOGGER = logging.getLogger(__name__)


class BaseRepository:
    """Base repository providing generic CRUD operations for a SQLite table.

    Subclasses must define:
        - table_name: str - The SQL table name.
        - allowed_columns: set[str] - Whitelist of column
          names for insert/update.
    """

    table_name: str = ""
    allowed_columns: set[str] = set()

    def __init__(self, db_manager: DatabaseManager) -> None:
        """Initialize with a shared DatabaseManager.

        Args:
            db_manager: The database manager providing the shared connection.
        """
        self.db = db_manager

    async def find_all(self) -> list[dict[str, Any]]:
        """Retrieve all rows from the table, ordered by id ASC.

        Returns:
            A list of dicts representing each row.
        """
        conn = await self.db.get_connection()
        cursor = await conn.execute(
            f"SELECT * FROM {self.table_name} ORDER BY id ASC"
        )
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]

    async def find_by_id(self, entity_id: int) -> Optional[dict[str, Any]]:
        """Retrieve a single row by its primary key.

        Args:
            entity_id: The integer primary key.

        Returns:
            A dict representing the row, or None if not found.
        """
        conn = await self.db.get_connection()
        cursor = await conn.execute(
            f"SELECT * FROM {self.table_name} WHERE id = ?", (entity_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None

    async def create(self, data: dict[str, Any]) -> int:
        """Insert a new row and return its auto-generated ID.

        Only columns listed in `allowed_columns` are written.

        Args:
            data: A dict of column names to values.

        Returns:
            The integer ID of the newly created row.

        Raises:
            ValueError: If the insert fails to produce an ID.
        """
        filtered = {k: v for k, v in data.items() if k in self.allowed_columns}
        if not filtered:
            conn = await self.db.get_connection()
            cursor = await conn.execute(
                f"INSERT INTO {self.table_name} DEFAULT VALUES"
            )
            await conn.commit()
            if cursor.lastrowid is None:
                raise ValueError("Failed to get ID after insert")
            return int(cursor.lastrowid)

        cols = list(filtered.keys())
        placeholders = ", ".join(["?"] * len(cols))
        col_list = ", ".join(cols)
        values = [filtered[c] for c in cols]

        conn = await self.db.get_connection()
        sql = (
            f"INSERT INTO {self.table_name}"
            f" ({col_list}) VALUES ({placeholders})"
        )
        cursor = await conn.execute(sql, tuple(values))
        await conn.commit()
        if cursor.lastrowid is None:
            raise ValueError("Failed to get ID after insert")
        _LOGGER.debug("Created %s (ID: %d)", self.table_name, cursor.lastrowid)
        return int(cursor.lastrowid)

    async def update(self, entity_id: int, data: dict[str, Any]) -> bool:
        """Update an existing row by ID.

        Only columns listed in `allowed_columns` are modified.
        Automatically sets updated_at to CURRENT_TIMESTAMP.

        Args:
            entity_id: The integer primary key.
            data: A dict of column names to new values.

        Returns:
            True if the update was applied, False if no valid columns provided.
        """
        filtered = {k: v for k, v in data.items() if k in self.allowed_columns}
        if not filtered:
            return False

        sets = [f"{k} = ?" for k in filtered]
        sets.append("updated_at = CURRENT_TIMESTAMP")
        values = list(filtered.values())
        values.append(entity_id)

        conn = await self.db.get_connection()
        await conn.execute(
            f"UPDATE {self.table_name} SET {', '.join(sets)} WHERE id = ?",
            tuple(values),
        )
        await conn.commit()
        _LOGGER.debug("Updated %s (ID: %d)", self.table_name, entity_id)
        return True

    async def delete(self, entity_id: int) -> bool:
        """Delete a row by ID.

        Args:
            entity_id: The integer primary key.

        Returns:
            True if a row was deleted, False otherwise.
        """
        conn = await self.db.get_connection()
        cursor = await conn.execute(
            f"DELETE FROM {self.table_name} WHERE id = ?", (entity_id,)
        )
        await conn.commit()
        deleted = cursor.rowcount > 0
        if deleted:
            _LOGGER.debug("Deleted %s (ID: %d)", self.table_name, entity_id)
        return deleted

    async def find_by_parent(self, parent_id: int) -> list[dict[str, Any]]:
        """Find rows by parent FK. Subclasses should override parent_column.

        Args:
            parent_id: The parent foreign key value.

        Returns:
            A list of dicts.
        """
        parent_column = getattr(self, "parent_column", None)
        if not parent_column:
            return []
        conn = await self.db.get_connection()
        sql = (
            f"SELECT * FROM {self.table_name}"
            f" WHERE {parent_column} = ?"
            " ORDER BY id ASC"
        )
        cursor = await conn.execute(sql, (parent_id,))
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]
